local conform = require "conform"
local lspconfig = require "lspconfig"
local mason = require "mason"
local mason_lspconfig = require "mason-lspconfig"
local mason_installer = require "mason-tool-installer"

local servers = {
  lua_ls = {},
}

local ensure_installed = {
  "stylua",
}

local servers_to_install = vim.tbl_filter(function(key)
  local t = servers[key]
  if type(t) == "table" then
    return not t.manual_install
  else
    return t
  end
end, vim.tbl_keys(servers))

mason.setup()
vim.list_extend(ensure_installed, servers_to_install)
mason_installer.setup { ensure_installed = ensure_installed }

for name, config in pairs(servers) do
  if config == true then
    config = {}
  end
  config = vim.tbl_deep_extend("force", {}, { capabilities = capabilities }, config)
  lspconfig[name].setup(config)
end

-- local disable_semantic_tokens = {
--   lua = true,
-- }
--
vim.api.nvim_create_autocmd("LspAttach", {
  callback = function(args)
    local bufnr = args.buf
    local client = assert(vim.lsp.get_client_by_id(args.data.client_id), "must have valid client")

    vim.opt_local.omnifunc = "v:lua.vim.lsp.omnifunc"
    --
    --     local filetype = vim.bo[bufnr].filetype
    --     if disable_semantic_tokens[filetype] then
    --       client.server_capabilities.semanticTokensProvider = nil
    --     end
  end,
})

conform.setup {
  formatters_by_ft = {
    lua = { "stylua" },
    python = { "ruff" },
    bash = { "shfmt" },
    zsh = { "shfmt" },
  },
}

vim.api.nvim_create_autocmd("BufWritePre", {
  callback = function(args)
    conform.format { bufnr = args.buf }
  end,
})

--
--
--
--
--
--
--
--
--
--
--
--
--
--
--

-- mason_lspconfig.setup_handlers {
--   server
-- }
--       mason_lspconfig.setup_handlers {
--         function(server_name)
--           lspconfig[server_name].setup {
--             capabilities = capabilities,
--           }
--         end,
--       }

-- mason_lspconfig.setup {
--   handlers = {
--     function(server_name)
--       local server = servers[server_name] or {}
--       server.capabilities = vim.tbl_deep_extend('force', {}, capabilities, server.capabilities or {})
--       lspconfig[server_name].setup(server)
--     end,
--   }
-- }

-- mason_lspconfig.setup_handlers {
--   server = function()
--     lspconfig.server.setup {}
--   end,
-- }

--
-- vim.api.nvim_create_autocmd('LspAttach', {
--   group = vim.api.nvim_create_augroup('lsp-attach', { clear = true }),
--   -- Create a function that lets us more easily define mappings specific LSP related items.
--   -- It sets the mode, buffer and description for us each time.
--   callback = function(event)
--     local map = function(keys, func, desc)
--       vim.keymap.set('n', keys, func, { buffer = event.buf, desc = 'LSP: ' .. desc })
--     end
--
--     -- Jump to the definition of the word under your cursor.
--     --  This is where a variable was first declared, or where a function is defined, etc.
--     --  To jump back, press <C-T>.
--     map('gd', require('telescope.builtin').lsp_definitions, '[G]oto [D]efinition')
--
--     -- Find references for the word under your cursor.
--     map('gr', require('telescope.builtin').lsp_references, '[G]oto [R]eferences')
--
--     -- Jump to the implementation of the word under your cursor.
--     --  Useful when your language has ways of declaring types without an actual implementation.
--     map('gI', require('telescope.builtin').lsp_implementations, '[G]oto [I]mplementation')
--
--     -- Jump to the type of the word under your cursor.
--     --  Useful when you're not sure what type a variable is and you want to see
--     --  the definition of its *type*, not where it was *defined*.
--     map('<leader>D', require('telescope.builtin').lsp_type_definitions, 'Type [D]efinition')
--
--     -- Fuzzy find all the symbols in your current document.
--     --  Symbols are things like variables, functions, types, etc.
--     map('<leader>ds', require('telescope.builtin').lsp_document_symbols, '[D]ocument [S]ymbols')
--
--     -- Fuzzy find all the symbols in your current workspace
--     --  Similar to document symbols, except searches over your whole project.
--     map('<leader>ws', require('telescope.builtin').lsp_dynamic_workspace_symbols, '[W]orkspace [S]ymbols')
--
--     -- Rename the variable under your cursor
--     --  Most Language Servers support renaming across files, etc.
--     map('<leader>rn', vim.lsp.buf.rename, '[R]e[n]ame')
--
--     -- Execute a code action, usually your cursor needs to be on top of an error
--     -- or a suggestion from your LSP for this to activate.
--     map('<leader>ca', vim.lsp.buf.code_action, '[C]ode [A]ction')
--
--     -- Opens a popup that displays documentation about the word under your cursor
--     --  See `:help K` for why this keymap
--     map('K', vim.lsp.buf.hover, 'Hover Documentation')
--
--     -- WARN: This is not Goto Definition, this is Goto Declaration.
--     --  For example, in C this would take you to the header
--     map('gD', vim.lsp.buf.declaration, '[G]oto [D]eclaration')
--
--     map('<leader>wa', vim.lsp.buf.add_workspace_folder, '[W]orkspace [A]dd Folder')
--     map('<leader>wr', vim.lsp.buf.remove_workspace_folder, '[W]orkspace [R]emove Folder')
--     map('<leader>wl', function()
--       print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
--     end, '[W]orkspace [L]ist Folders')
--
--     -- The following two autocommands are used to highlight references of the
--     -- word under your cursor when your cursor rests there for a little while.
--     --    See `:help CursorHold` for information about when this is executed
--     --
--     -- When you move your cursor, the highlights will be cleared (the second autocommand).
--     local client = vim.lsp.get_client_by_id(event.data.client_id)
--     if client and client.server_capabilities.documentHighlightProvider then
--       vim.api.nvim_create_autocmd({ 'CursorHold', 'CursorHoldI' }, {
--         buffer = event.buf,
--         callback = vim.lsp.buf.document_highlight,
--       })
--
--       vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {
--         buffer = event.buf,
--         callback = vim.lsp.buf.clear_references,
--       })
--     end
--   end,
-- })
--
-- local capabilities = vim.lsp.protocol.make_client_capabilities()
-- capabilities = vim.tbl_deep_extend('force', capabilities, require('blink.cmp').default_capabilities())
--
-- -- Enable the following language servers
-- local servers = {
--   lua_ls = {
--     -- cmd = {...},
--     -- filetypes { ...},
--     -- capabilities = {},
--     settings = {
--       Lua = {
--         runtime = { version = 'LuaJIT' },
--         workspace = {
--           checkThirdParty = false,
--           -- Tells lua_ls where to find all the Lua files that you have loaded
--           -- for your neovim configuration.
--           library = {
--             '${3rd}/luv/library',
--             unpack(vim.api.nvim_get_runtime_file('', true)),
--           },
--           -- If lua_ls is really slow on your computer, you can try this instead:
--           -- library = { vim.env.VIMRUNTIME },
--         },
--         completion = {
--           callSnippet = 'Replace',
--         },
--         telemetry = { enable = false },
--         diagnostics = { disable = { 'missing-fields' } },
--       },
--     },
--   },
--   pylsp = {
--     settings = {
--       pylsp = {
--         plugins = {
--           pyflakes = { enabled = false },
--           pycodestyle = { enabled = false },
--           autopep8 = { enabled = false },
--           yapf = { enabled = false },
--           mccabe = { enabled = false },
--           pylsp_mypy = { enabled = false },
--           pylsp_black = { enabled = false },
--           pylsp_isort = { enabled = false },
--         },
--       },
--     },
--   },
--   -- basedpyright = {
--   --   -- Config options: https://github.com/DetachHead/basedpyright/blob/main/docs/settings.md
--   --   settings = {
--   --     basedpyright = {
--   --       disableOrganizeImports = true, -- Using Ruff's import organizer
--   --       disableLanguageServices = false,
--   --       analysis = {
--   --         ignore = { '*' },                 -- Ignore all files for analysis to exclusively use Ruff for linting
--   --         typeCheckingMode = 'off',
--   --         diagnosticMode = 'openFilesOnly', -- Only analyze open files
--   --         useLibraryCodeForTypes = true,
--   --         autoImportCompletions = true,     -- whether pyright offers auto-import completions
--   --       },
--   --     },
--   --   },
--   -- },
--   ruff = {
--     -- Notes on code actions: https://github.com/astral-sh/ruff-lsp/issues/119#issuecomment-1595628355
--     -- Get isort like behavior: https://github.com/astral-sh/ruff/issues/8926#issuecomment-1834048218
--     commands = {
--       RuffAutofix = {
--         function()
--           vim.lsp.buf.execute_command {
--             command = 'ruff.applyAutofix',
--             arguments = {
--               { uri = vim.uri_from_bufnr(0) },
--             },
--           }
--         end,
--         description = 'Ruff: Fix all auto-fixable problems',
--       },
--       RuffOrganizeImports = {
--         function()
--           vim.lsp.buf.execute_command {
--             command = 'ruff.applyOrganizeImports',
--             arguments = {
--               { uri = vim.uri_from_bufnr(0) },
--             },
--           }
--         end,
--         description = 'Ruff: Format imports',
--       },
--     },
--   },
--   jsonls = {},
--   sqlls = {},
--   terraformls = {},
--   yamlls = {},
--   bashls = {},
--   dockerls = {},
--   docker_compose_language_service = {},
--   -- tailwindcss = {},
--   -- graphql = {},
--   -- html = { filetypes = { 'html', 'twig', 'hbs' } },
--   -- cssls = {},
--   -- ltex = {},
--   -- texlab = {},
-- }
--
-- -- -- Ensure the servers and tools above are installed
-- -- require('mason').setup()
--
-- -- You can add other tools here that you want Mason to install
-- -- for you, so that they are available from within Neovim.
-- local ensure_installed = vim.tbl_keys(servers or {})
-- vim.list_extend(ensure_installed, {
--   'stylua', -- Used to format lua code
-- })
-- require('mason-tool-installer').setup { ensure_installed = ensure_installed }
--
-- require('mason-lspconfig').setup {
--   handlers = {
--     function(server_name)
--       local server = servers[server_name] or {}
--       -- This handles overriding only values explicitly passed
--       -- by the server configuration above. Useful when disabling
--       -- certain features of an LSP (for example, turning off formatting for tsserver)
--       server.capabilities = vim.tbl_deep_extend('force', {}, capabilities, server.capabilities or {})
--       require('lspconfig')[server_name].setup(server)
--     end,
--   },
-- }
-- return {
--       'neovim/nvim-lspconfig',
--       dependencies = {
--         -- Automatically install LSPs and related tools to stdpath for Neovim
--         -- Mason must be loaded before its dependents so we need to set it up here.
--         -- NOTE: `opts = {}` is the same as calling `require('mason').setup({})`
--         { 'williamboman/mason.nvim', opts = {} },
--         'williamboman/mason-lspconfig.nvim',
--         'WhoIsSethDaniel/mason-tool-installer.nvim',
--
--         -- Useful status updates for LSP.
--         { 'j-hui/fidget.nvim',       opts = {} },
--
--         -- Allows extra capabilities provided by nvim-cmp
--         'hrsh7th/cmp-nvim-lsp',
--       },
--       config = function()
--         -- Brief aside: **What is LSP?**
--         --
--         -- LSP is an initialism you've probably heard, but might not understand what it is.
--         --
--         -- LSP stands for Language Server Protocol. It's a protocol that helps editors
--         -- and language tooling communicate in a standardized fashion.
--         --
--         -- In general, you have a "server" which is some tool built to understand a particular
--         -- language (such as `gopls`, `lua_ls`, `rust_analyzer`, etc.). These Language Servers
--         -- (sometimes called LSP servers, but that's kind of like ATM Machine) are standalone
--         -- processes that communicate with some "client" - in this case, Neovim!
--         --
--         -- LSP provides Neovim with features like:
--         --  - Go to definition
--         --  - Find references
--         --  - Autocompletion
--         --  - Symbol Search
--         --  - and more!
--         --
--         -- Thus, Language Servers are external tools that must be installed separately from
--         -- Neovim. This is where `mason` and related plugins come into play.
--         --
--         -- If you're wondering about lsp vs treesitter, you can check out the wonderfully
--         -- and elegantly composed help section, `:help lsp-vs-treesitter`
--
--         --  This function gets run when an LSP attaches to a particular buffer.
--         --    That is to say, every time a new file is opened that is associated with
--         --    an lsp (for example, opening `main.rs` is associated with `rust_analyzer`) this
--         --    function will be executed to configure the current buffer
--         vim.api.nvim_create_autocmd('LspAttach', {
--           group = vim.api.nvim_create_augroup('kickstart-lsp-attach', { clear = true }),
--           callback = function(event)
--             -- NOTE: Remember that Lua is a real programming language, and as such it is possible
--             -- to define small helper and utility functions so you don't have to repeat yourself.
--             --
--             -- In this case, we create a function that lets us more easily define mappings specific
--             -- for LSP related items. It sets the mode, buffer and description for us each time.
--             local map = function(keys, func, desc, mode)
--               mode = mode or 'n'
--               vim.keymap.set(mode, keys, func, { buffer = event.buf, desc = 'LSP: ' .. desc })
--             end
--
--             -- Jump to the definition of the word under your cursor.
--             --  This is where a variable was first declared, or where a function is defined, etc.
--             --  To jump back, press <C-t>.
--             map('gd', require('telescope.builtin').lsp_definitions, '[G]oto [D]efinition')
--
--             -- Find references for the word under your cursor.
--             map('gr', require('telescope.builtin').lsp_references, '[G]oto [R]eferences')
--
--             -- Jump to the implementation of the word under your cursor.
--             --  Useful when your language has ways of declaring types without an actual implementation.
--             map('gI', require('telescope.builtin').lsp_implementations, '[G]oto [I]mplementation')
--
--             -- Jump to the type of the word under your cursor.
--             --  Useful when you're not sure what type a variable is and you want to see
--             --  the definition of its *type*, not where it was *defined*.
--             map('<leader>D', require('telescope.builtin').lsp_type_definitions, 'Type [D]efinition')
--
--             -- Fuzzy find all the symbols in your current document.
--             --  Symbols are things like variables, functions, types, etc.
--             map('<leader>ds', require('telescope.builtin').lsp_document_symbols, '[D]ocument [S]ymbols')
--
--             -- Fuzzy find all the symbols in your current workspace.
--             --  Similar to document symbols, except searches over your entire project.
--             map('<leader>ws', require('telescope.builtin').lsp_dynamic_workspace_symbols, '[W]orkspace [S]ymbols')
--
--             -- Rename the variable under your cursor.
--             --  Most Language Servers support renaming across files, etc.
--             map('<leader>rn', vim.lsp.buf.rename, '[R]e[n]ame')
--
--             -- Execute a code action, usually your cursor needs to be on top of an error
--             -- or a suggestion from your LSP for this to activate.
--             map('<leader>ca', vim.lsp.buf.code_action, '[C]ode [A]ction', { 'n', 'x' })
--
--             -- WARN: This is not Goto Definition, this is Goto Declaration.
--             --  For example, in C this would take you to the header.
--             map('gD', vim.lsp.buf.declaration, '[G]oto [D]eclaration')
--
--             -- This function resolves a difference between neovim nightly (version 0.11) and stable (version 0.10)
--             ---@param client vim.lsp.Client
--             ---@param method vim.lsp.protocol.Method
--             ---@param bufnr? integer some lsp support methods only in specific files
--             ---@return boolean
--             local function client_supports_method(client, method, bufnr)
--               if vim.fn.has 'nvim-0.11' == 1 then
--                 return client:supports_method(method, bufnr)
--               else
--                 return client.supports_method(method, { bufnr = bufnr })
--               end
--             end
--
--             -- The following two autocommands are used to highlight references of the
--             -- word under your cursor when your cursor rests there for a little while.
--             --    See `:help CursorHold` for information about when this is executed
--             --
--             -- When you move your cursor, the highlights will be cleared (the second autocommand).
--             local client = vim.lsp.get_client_by_id(event.data.client_id)
--             if client and client_supports_method(client, vim.lsp.protocol.Methods.textDocument_documentHighlight, event.buf) then
--               local highlight_augroup = vim.api.nvim_create_augroup('kickstart-lsp-highlight', { clear = false })
--               vim.api.nvim_create_autocmd({ 'CursorHold', 'CursorHoldI' }, {
--                 buffer = event.buf,
--                 group = highlight_augroup,
--                 callback = vim.lsp.buf.document_highlight,
--               })
--
--               vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {
--                 buffer = event.buf,
--                 group = highlight_augroup,
--                 callback = vim.lsp.buf.clear_references,
--               })
--
--               vim.api.nvim_create_autocmd('LspDetach', {
--                 group = vim.api.nvim_create_augroup('kickstart-lsp-detach', { clear = true }),
--                 callback = function(event2)
--                   vim.lsp.buf.clear_references()
--                   vim.api.nvim_clear_autocmds { group = 'kickstart-lsp-highlight', buffer = event2.buf }
--                 end,
--               })
--             end
--
--             -- The following code creates a keymap to toggle inlay hints in your
--             -- code, if the language server you are using supports them
--             --
--             -- This may be unwanted, since they displace some of your code
--             if client and client_supports_method(client, vim.lsp.protocol.Methods.textDocument_inlayHint, event.buf) then
--               map('<leader>th', function()
--                 vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled { bufnr = event.buf })
--               end, '[T]oggle Inlay [H]ints')
--             end
--           end,
--         })
--
--         -- Diagnostic Config
--         -- See :help vim.diagnostic.Opts
--         vim.diagnostic.config {
--           severity_sort = true,
--           float = { border = 'rounded', source = 'if_many' },
--           underline = { severity = vim.diagnostic.severity.ERROR },
--           signs = vim.g.have_nerd_font and {
--             text = {
--               [vim.diagnostic.severity.ERROR] = '󰅚 ',
--               [vim.diagnostic.severity.WARN] = '󰀪 ',
--               [vim.diagnostic.severity.INFO] = '󰋽 ',
--               [vim.diagnostic.severity.HINT] = '󰌶 ',
--             },
--           } or {},
--           virtual_text = {
--             source = 'if_many',
--             spacing = 2,
--             format = function(diagnostic)
--               local diagnostic_message = {
--                 [vim.diagnostic.severity.ERROR] = diagnostic.message,
--                 [vim.diagnostic.severity.WARN] = diagnostic.message,
--                 [vim.diagnostic.severity.INFO] = diagnostic.message,
--                 [vim.diagnostic.severity.HINT] = diagnostic.message,
--               }
--               return diagnostic_message[diagnostic.severity]
--             end,
--           },
--         }
--
--         -- LSP servers and clients are able to communicate to each other what features they support.
--         --  By default, Neovim doesn't support everything that is in the LSP specification.
--         --  When you add nvim-cmp, luasnip, etc. Neovim now has *more* capabilities.
--         --  So, we create new capabilities with nvim cmp, and then broadcast that to the servers.
--         local capabilities = vim.lsp.protocol.make_client_capabilities()
--         capabilities = vim.tbl_deep_extend('force', capabilities, require('cmp_nvim_lsp').default_capabilities())
--
--         -- Enable the following language servers
--         --  Feel free to add/remove any LSPs that you want here. They will automatically be installed.
--         --
--         --  Add any additional override configuration in the following tables. Available keys are:
--         --  - cmd (table): Override the default command used to start the server
--         --  - filetypes (table): Override the default list of associated filetypes for the server
--         --  - capabilities (table): Override fields in capabilities. Can be used to disable certain LSP features.
--         --  - settings (table): Override the default settings passed when initializing the server.
--         --        For example, to see the options for `lua_ls`, you could go to: https://luals.github.io/wiki/settings/
--         local servers = {
--           -- clangd = {},
--           -- gopls = {},
--           -- pyright = {},
--           -- rust_analyzer = {},
--           -- ... etc. See `:help lspconfig-all` for a list of all the pre-configured LSPs
--           --
--           -- Some languages (like typescript) have entire language plugins that can be useful:
--           --    https://github.com/pmizio/typescript-tools.nvim
--           --
--           -- But for many setups, the LSP (`ts_ls`) will work just fine
--           -- ts_ls = {},
--           --
--
--           lua_ls = {
--             -- cmd = { ... },
--             -- filetypes = { ... },
--             -- capabilities = {},
--             settings = {
--               Lua = {
--                 completion = {
--                   callSnippet = 'Replace',
--                 },
--                 -- You can toggle below to ignore Lua_LS's noisy `missing-fields` warnings
--                 -- diagnostics = { disable = { 'missing-fields' } },
--               },
--             },
--           },
--         }
--
--         -- Ensure the servers and tools above are installed
--         --
--         -- To check the current status of installed tools and/or manually install
--         -- other tools, you can run
--         --    :Mason
--         --
--         -- You can press `g?` for help in this menu.
--         --
--         -- `mason` had to be setup earlier: to configure its options see the
--         -- `dependencies` table for `nvim-lspconfig` above.
--         --
--         -- You can add other tools here that you want Mason to install
--         -- for you, so that they are available from within Neovim.
--         local ensure_installed = vim.tbl_keys(servers or {})
--         vim.list_extend(ensure_installed, {
--           'stylua', -- Used to format Lua code
--         })
--         require('mason-tool-installer').setup { ensure_installed = ensure_installed }
--
--         require('mason-lspconfig').setup {
--           ensure_installed = {}, -- explicitly set to an empty table (Kickstart populates installs via mason-tool-installer)
--           automatic_installation = false,
--           handlers = {
--             function(server_name)
--               local server = servers[server_name] or {}
--               -- This handles overriding only values explicitly passed
--               -- by the server configuration above. Useful when disabling
--               -- certain features of an LSP (for example, turning off formatting for ts_ls)
--               server.capabilities = vim.tbl_deep_extend('force', {}, capabilities, server.capabilities or {})
--               require('lspconfig')[server_name].setup(server)
--             end,
--           },
--         }
--       end,
--     },
--
--     { -- Autoformat
--       'stevearc/conform.nvim',
--       event = { 'BufWritePre' },
--       cmd = { 'ConformInfo' },
--       keys = {
--         {
--           '<leader>f',
--           function()
--             require('conform').format { async = true, lsp_format = 'fallback' }
--           end,
--           mode = '',
--           desc = '[F]ormat buffer',
--         },
--       },
--       opts = {
--         notify_on_error = false,
--         format_on_save = function(bufnr)
--           -- Disable "format_on_save lsp_fallback" for languages that don't
--           -- have a well standardized coding style. You can add additional
--           -- languages here or re-enable it for the disabled ones.
--           local disable_filetypes = { c = true, cpp = true }
--           local lsp_format_opt
--           if disable_filetypes[vim.bo[bufnr].filetype] then
--             lsp_format_opt = 'never'
--           else
--             lsp_format_opt = 'fallback'
--           end
--           return {
--             timeout_ms = 500,
--             lsp_format = lsp_format_opt,
--           }
--         end,
--         formatters_by_ft = {
--           lua = { 'stylua' },
--           -- Conform can also run multiple formatters sequentially
--           -- python = { "isort", "black" },
--           --
--           -- You can use 'stop_after_first' to run the first available formatter from the list
--           -- javascript = { "prettierd", "prettier", stop_after_first = true },
--         },
--       },
--     },
--
--     { -- Autocompletion
--       'hrsh7th/nvim-cmp',
--       event = 'InsertEnter',
--       dependencies = {
--         -- Snippet Engine & its associated nvim-cmp source
--         {
--           'L3MON4D3/LuaSnip',
--           build = (function()
--             -- Build Step is needed for regex support in snippets.
--             -- This step is not supported in many windows environments.
--             -- Remove the below condition to re-enable on windows.
--             if vim.fn.has 'win32' == 1 or vim.fn.executable 'make' == 0 then
--               return
--             end
--             return 'make install_jsregexp'
--           end)(),
--           dependencies = {
--             -- `friendly-snippets` contains a variety of premade snippets.
--             --    See the README about individual language/framework/plugin snippets:
--             --    https://github.com/rafamadriz/friendly-snippets
--             -- {
--             --   'rafamadriz/friendly-snippets',
--             --   config = function()
--             --     require('luasnip.loaders.from_vscode').lazy_load()
--             --   end,
--             -- },
--           },
--         },
--         'saadparwaiz1/cmp_luasnip',
--
--         -- Adds other completion capabilities.
--         --  nvim-cmp does not ship with all sources by default. They are split
--         --  into multiple repos for maintenance purposes.
--         'hrsh7th/cmp-nvim-lsp',
--         'hrsh7th/cmp-path',
--         'hrsh7th/cmp-nvim-lsp-signature-help',
--       },
--       config = function()
--         -- See `:help cmp`
--         local cmp = require 'cmp'
--         local luasnip = require 'luasnip'
--         luasnip.config.setup {}
--
--         cmp.setup {
--           snippet = {
--             expand = function(args)
--               luasnip.lsp_expand(args.body)
--             end,
--           },
--           completion = { completeopt = 'menu,menuone,noinsert' },
--
--           -- For an understanding of why these mappings were
--           -- chosen, you will need to read `:help ins-completion`
--           --
--           -- No, but seriously. Please read `:help ins-completion`, it is really good!
--           mapping = cmp.mapping.preset.insert {
--             -- Select the [n]ext item
--             ['<C-n>'] = cmp.mapping.select_next_item(),
--             -- Select the [p]revious item
--             ['<C-p>'] = cmp.mapping.select_prev_item(),
--
--             -- Scroll the documentation window [b]ack / [f]orward
--             ['<C-b>'] = cmp.mapping.scroll_docs(-4),
--             ['<C-f>'] = cmp.mapping.scroll_docs(4),
--
--             -- Accept ([y]es) the completion.
--             --  This will auto-import if your LSP supports it.
--             --  This will expand snippets if the LSP sent a snippet.
--             ['<C-y>'] = cmp.mapping.confirm { select = true },
--
--             -- If you prefer more traditional completion keymaps,
--             -- you can uncomment the following lines
--             --['<CR>'] = cmp.mapping.confirm { select = true },
--             --['<Tab>'] = cmp.mapping.select_next_item(),
--             --['<S-Tab>'] = cmp.mapping.select_prev_item(),
--
--             -- Manually trigger a completion from nvim-cmp.
--             --  Generally you don't need this, because nvim-cmp will display
--             --  completions whenever it has completion options available.
--             ['<C-Space>'] = cmp.mapping.complete {},
--
--             -- Think of <c-l> as moving to the right of your snippet expansion.
--             --  So if you have a snippet that's like:
--             --  function $name($args)
--             --    $body
--             --  end
--             --
--             -- <c-l> will move you to the right of each of the expansion locations.
--             -- <c-h> is similar, except moving you backwards.
--             ['<C-l>'] = cmp.mapping(function()
--               if luasnip.expand_or_locally_jumpable() then
--                 luasnip.expand_or_jump()
--               end
--             end, { 'i', 's' }),
--             ['<C-h>'] = cmp.mapping(function()
--               if luasnip.locally_jumpable(-1) then
--                 luasnip.jump(-1)
--               end
--             end, { 'i', 's' }),
--
--             -- For more advanced Luasnip keymaps (e.g. selecting choice nodes, expansion) see:
--             --    https://github.com/L3MON4D3/LuaSnip?tab=readme-ov-file#keymaps
--           },
--           sources = {
--             {
--               name = 'lazydev',
--               -- set group index to 0 to skip loading LuaLS completions as lazydev recommends it
--               group_index = 0,
--             },
--             { name = 'nvim_lsp' },
--             { name = 'luasnip' },
--             { name = 'path' },
--             { name = 'nvim_lsp_signature_help' },
--           },
--         }
--       end,
--     }
--
-- local capabilities = vim.lsp.protocol.make_client_capabilities()

-- local servsers = {
--   gopls = {},
--   pyright = {},
--   lua_ls = {},
-- }

-- local capabilities = nil
-- if pcall(require, "blink.cmp") then
--   capabilities = require("blink.cmp").get_lsp_capabilities()
-- end
--
-- local lspconfig = require "lspconfig"
--
-- local servers = {
--   lua_ls = true,
-- }
--
-- local servers_to_install = vim.tbl_filter(function(key)
--   local t = servers[key]
--   if type(t) == "table" then
--     return not t.manual_install
--   else
--     return t
--   end
-- end, vim.tbl_keys(servers)
-- )
--
-- require("mason").setup()
-- local ensure_installed = {
--   "stylua"
-- }
--
-- vim.list_extend(ensure_installed,servers_to_install)
-- require("mason-tool-installer").setup{ensure_installed=ensure_installed}
--
-- for name, config in pairs(servers) do
--   if config == true then config = {}
--   end config = vim.tbl_deep_extend("force",{},{capabilities =capabilites,},config)
--   lspconfig[name].setup(config)
-- end
--
--
--       vim.api.nvim_create_autocmd("LspAttach", {
--         callback = function(args)
--           local bufnr = args.buf
--           local client = assert(vim.lsp.get_client_by_id(args.data.client_id), "must have valid client")
--
--           vim.opt_local.omnifunc = "v:lua.vim.lsp.omnifunc"
--           vim.keymap.set("n", "gd", vim.lsp.buf.definition, { buffer = 0 })
--           vim.keymap.set("n", "gr", vim.lsp.buf.references, { buffer = 0 })
--           vim.keymap.set("n", "gD", vim.lsp.buf.declaration, { buffer = 0 })
--           vim.keymap.set("n", "gT", vim.lsp.buf.type_definition, { buffer = 0 })
--           vim.keymap.set("n", "K", vim.lsp.buf.hover, { buffer = 0 })
--
--           vim.keymap.set("n", "<space>cr", vim.lsp.buf.rename, { buffer = 0 })
--           vim.keymap.set("n", "<space>ca", vim.lsp.buf.code_action, { buffer = 0 })
--
--           -- local filetype = vim.bo[bufnr].filetype
--           -- if disable_semantic_tokens[filetype] then
--           --   client.server_capabilities.semanticTokensProvider = nil
--           -- end
--         end,
--       })
--
--     dependencies = {
--   {
--   'saghen/blink.cmp',
--   dependencies = 'rafamadriz/friendly-snippets',
--   version = '*',
--   opts = {
--     keymap = { preset = 'default' },
--     appearance = {
--       use_nvim_cmp_as_default = true,
--       nerd_font_variant = 'mono'
--     },
--     sources = {
--       default = {"lazydev", 'lsp', 'path', 'snippets', 'buffer' },
--       providers = {
--         lazydev = {
--           name = "LazyDev",
--           module = "lazydev.integrations.blink",
--           score_offset = 100,
--         }
--       }
--     },
--     fuzzy = { implementation = "prefer_rust_with_warning" }
--   },
--   opts_extend = { "sources.default" }
-- },
--       },
--       "williamboman/mason.nvim",
--       "williamboman/mason-lspconfig.nvim",
--       "WhoIsSethDaniel/mason-tool-installer.nvim",
--       { "j-hui/fidget.nvim", opts = {} },
--             "stevearc/conform.nvim",
--              "b0o/SchemaStore.nvim",
--     },
--     config = function()
--       local capabilities = require('blink.cmp').get_lsp_capabilities()
--       require("lspconfig").lua_ls.setup { capabilites = capabilities }
--
--       vim.api.nvim_create_autocmd('LspAttach', {
--         callback = function(args)
--           local c = vim.lsp.get_client_by_id(args.data.client_id)
--           if not c then return end
--
--           if vim.bo.filetype == "lua" then
--             -- Format the current buffer on save
--             vim.api.nvim_create_autocmd('BufWritePre', {
--               buffer = args.buf,
--               callback = function()
--                 vim.lsp.buf.format({ bufnr = args.buf, id = c.id })
--               end,
--             })
--           end
--         end,
--       })
--     end,
--   }
-- }
-- return {
--   {
--     "neovim/nvim-lspconfig",
--     dependencies = {
--       {
--         "saghen/blink.cmp",
--         dependencies = "rafamadriz/friendly-snippets",
--         version = "*",
--         opts = {
--           keymap = { preset = "default" },
--           appearance = {
--             use_nvim_cmp_as_default = true,
--             nerd_font_variant = "mono",
--           },
--           sources = {
--             default = { "lazydev", "lsp", "path", "snippets", "buffer" },
--             providers = {
--               lazydev = {
--                 name = "LazyDev",
--                 module = "lazydev.integrations.blink",
--                 score_offset = 100,
--               },
--             },
--           },
--           fuzzy = { implementation = "prefer_rust_with_warning" },
--         },
--         opts_extend = { "sources.default" },
--       },
--       {
--         "folke/lazydev.nvim",
--         opts = {
--           library = {
--             { path = "${3rd}/luv/library", words = { "vim%.uv" } },
--           },
--         },
--       },
--       "williamboman/mason.nvim",
--       "williamboman/mason-lspconfig.nvim",
--       "WhoIsSethDaniel/mason-tool-installer.nvim",
--       { "j-hui/fidget.nvim", opts = {} },
--       "stevearc/conform.nvim",
--       "b0o/SchemaStore.nvim",
--     },
--     config = function()
--       local capabilities = require("blink.cmp").get_lsp_capabilities()
--       local lspconfig = require("lspconfig")
--
--       -- Configure language servers using mason-lspconfig
--       local mason_lspconfig = require("mason-lspconfig")
--
--       mason_lspconfig.setup {
--         ensure_installed = { "lua_ls", "gopls", "sqlls", "pyright" }, -- Add language servers here
--       }
--
--       mason_lspconfig.setup_handlers {
--         function(server_name)
--           lspconfig[server_name].setup {
--             capabilities = capabilities,
--           }
--         end,
--       }
--
--       -- Keymaps
--       local keymap = vim.keymap.set
--       keymap("n", "gd", vim.lsp.buf.definition, { desc = "Go to definition" })
--       keymap("n", "gD", vim.lsp.buf.declaration, { desc = "Go to declaration" })
--       keymap("n", "gi", vim.lsp.buf.implementation, { desc = "Go to implementation" })
--       keymap("n", "gr", vim.lsp.buf.references, { desc = "Go to references" })
--       keymap("n", "<leader>rn", vim.lsp.buf.rename, { desc = "Rename" })
--       keymap("n", "<leader>ca", vim.lsp.buf.code_action, { desc = "Code action" })
--       keymap("n", "<leader>f", vim.lsp.buf.format, { desc = "Format" })
--
--       -- Conform setup
--       require("conform").setup {
--         formatters_by_ft = {
--           lua = { "stylua" },
--           python = { "black" },
--           go = { "goimports", "gofmt" },
--           sql = { "sqlformat" },
--           -- Add more formatters for other filetypes
--         },
--         format_on_save = {
--           lsp_fallback = true,
--           async = false,
--           timeout_ms = 1000,
--         },
--       }
--
--       -- LSP Attach Autocommand
--       vim.api.nvim_create_autocmd("LspAttach", {
--         callback = function(args)
--           local client = vim.lsp.get_client_by_id(args.data.client_id)
--           if not client then
--             return
--           end
--
--           local bufnr = args.buf
--
--           -- Enable formatting on save for specific filetypes
--           if vim.bo[bufnr].filetype == "lua" then
--             vim.api.nvim_create_autocmd("BufWritePre", {
--               buffer = bufnr,
--               callback = function()
--                 vim.lsp.buf.format { bufnr = bufnr, id = client.id }
--               end,
--             })
--           end
--
--           -- Add more filetype-specific configurations here
--         end,
--       })
--     end,
--   },
-- }
--
--
